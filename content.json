{"meta":{"title":"木筏的博客","subtitle":"","description":"","author":"木筏","url":"https://yuliascott.github.io/blog"},"pages":[{"title":"404","date":"2020-12-28T11:12:53.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"/404.html","permalink":"https://yuliascott.github.io/blog/404.html","excerpt":"","text":"很抱歉，您所访问的地址并不存在！"},{"title":"时间轴","date":"2020-12-28T11:15:53.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"archives/index.html","permalink":"https://yuliascott.github.io/blog/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-12-28T11:12:53.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"categories/index.html","permalink":"https://yuliascott.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Webpack实战(2)-居玉皓著","slug":"Webpack实战(2)-居玉皓著","date":"2021-03-12T16:12:48.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"技术读物/Webpack实战(2)-居玉皓著/","link":"","permalink":"https://yuliascott.github.io/blog/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/Webpack%E5%AE%9E%E6%88%98(2)-%E5%B1%85%E7%8E%89%E7%9A%93%E8%91%97/","excerpt":"","text":"基于《Webpack实战 入门、进阶与调优》学习Webpack，搭建学习demo，共两个部分，本文是第二部分。 —七、代码分片代码分片可以有效降低首屏加载资源的大小，同时也会带来新的问题，如哪些模块进行分片、分片后的资源如何处理等。 CommonsChunkPlugin：Webpack 4之前内部自带的插件 optimization.SplitChunks：是Webpack 4为了改进CommonsChunkPlugin而重新设计和实现的代码分片特性 当前Webpack版本 5.23.0，配置optimization.SplitChunks： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* eslint-disable no-undef */let ENV = process.env.ENV;let isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;[name].js&#x27;, //:&#x27;bundle.js&#x27;, &#125;, mode: ENV, optimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27; &#125; &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, publicPath: &#x27;/&#x27;, &#125; &#125; &#125;, &#123; test: /\\.(js|jsx)$/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, //缓存机制, 重复打包未改变的模块防止二次编译 presets: [[ &#x27;@babel/env&#x27;, &#123; modules: false, //禁用模块语句的转化, 将ES6 Module的语法交给Webpack本身处理 &#125; ], [ &#x27;@babel/preset-react&#x27;, &#123; modules: false, &#125; ]], &#125; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 执行npm run dev，查看打包结果： 八、生产环境配置8.1 配置生产和开发环境1）使用相同的配置文件： package.json： 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;set ENV=production&amp;&amp; webpack&quot;, //‘&amp;&amp;’前面不要加空格，否则获取的值包含空格 &quot;dev&quot;: &quot;set ENV=development&amp;&amp; webpack-dev-server&quot;,&#125;, webpack.config.js： 12345678910111213141516171819202122232425const ENV = process.env.ENV;const isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;bundle.js&#x27;, &#125;, mode: ENV, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#x27;file-loader&#x27;, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 执行npm run build，即可查看dist目录生成的文件； 许多框架和库都采用process.env.NODE_ENV作为一个区别开发环境和生产环境的变量。process.env是Node.js用于保存当前进程环境变量的对象；而NODE_ENV则可以让开发者指定当前的运行环境。 2）为不同的环境创建各自的配置文件： 生产环境创建一个webpack.production.config.js，开发环境创建一个叫webpack.development.config.js，然后修改package.json： 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --config=webpack.production.config.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.development.config.js&quot;,&#125;, 将webpack.production.config.js和webpack.development.config.js的公共的配置提取出来，单独创建一个webpack.common.config.js； 让另外两个JS分别引用webpack.common.config.js，并添加自身环境的配置；也可以使用webpack-merge，它是一个专门用来做Webpack配置合并的工具； 8.2 —source mapsource map指的是将编译、打包、压缩后的代码映射回源代码的过程。Webpack打包压缩后的代码基本不具备可读性，若代码抛出一个错误，有了source map，再加上浏览器调试工具（devtools），就非常容易了。 JavaScript的source map配置很简单，只要在webpack.config.js中添加devtool即可： 1234module.exports = &#123; // ... devtool:&#x27;source-map&#x27;,&#125; App.js： 1234567891011121314151617import React from &#x27;react&#x27;;import &#x27;./App.css&#x27;;class App extends React.Component &#123; render() &#123; console.log(123); return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;app&quot;&gt; 这是App组件！ &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 执行npm run dev，F12打开chrome Dev Tool： 对于CSS、SCSS、Less来说，则需要添加额外的source map配置项： 123456789101112131415module.exports = &#123; // ... module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; sourceMap: true, &#125; &#125;, &#x27;postcss-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;] &#125;&#125; Webpack支持多种source map的形式。除了配置为devtool：’source-map’以外，还可以根据不同的需求选择cheap-source-map、eval-source-map等。 有了source map意味着任何人通过浏览器的开发者工具都可以看到工程源码，存在极大的安全性。如何保持功能的同时，防止暴露源码给用户呢？Webpack提供了hidden-source-map和nosources-source-map两种策略来提升source map的安全性。 hidden-source-map意味着Webpack仍然会产生完整的map文件，只不过不会在bundle文件中添加对于map文件的引用。若我们想要追溯源码，则需要利用一些第三方服务，将map文件上传到上面。目前流行的解决方案是Sentry。 nosources-source-map对于安全保护没那么强，但是使用方式相对简单，可以在浏览器开发者工具的sources选项卡中看到源码的目录结构，但是文件的具体内容会被隐藏起来。 在这些配置之外，我们还可以正常打包出source map，然后通过服务器的nginx设置将.map文件只对固定的白名单（比如公司内网）开放，这样我们仍然能看到源码，而一般用户的浏览器中无法获取。 8.3 资源压缩8.3.1 压缩JSWebpack 3开启压缩需调用webpack.optimize.UglifyJsPlugin； Webpack 4配置移到config.optimization.minimize： 123456module.exports = &#123; // ... optimization: &#123; minimize: true, &#125;,&#125; terser-webpack-plugin插件配置。 8.3.2 压缩CSS压缩CSS文件的前提是使用extract-text-webpack-plugin或mini-css-extract-plugin将样式提取出来，接着使用optimize-css-assets-webpack-plugin来进行压缩，这个插件本质上使用的是压缩器cssnano。 8.3.3 缓存1）资源hash 一个常用的方法是在每次打包的过程中对资源的内容计算一次hash，并作为版本号存放在文件名中，如bundle@2e0a691e769edb228e2.js。bundle是文件本身的名字，@后面跟的是文件内容hash值，每当代码发生变化时相应的hash也会变化。 2）输出动态HTML 资源名的改变意味着HTML中的引用路径的改变。每次更改后都要手动去维护很麻烦，理想的情况是打包结束后自动把最新的资源名同步过去。使用html-webpack-plugin插件： 1npm install html-webpack-plugin --save-dev 当前版本html-webpack-plugin 5.2.0； webpack.config.js： 12345678910const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);module.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27; &#125;) ]&#125; 注释index.html中引用bundle.js的script标签； 执行npm run dev，验证结果； 3）使chunk id更稳定 理想状态下，对于缓存的应用是尽量让用户在启动时只更新代码变化的部分，而对没有变化的部分使用缓存。 之前我们介绍过使用CommonsChunkPlugin和SplitChunksPlugin来划分代码。通过它们来尽可能地将一些不常变动的代码单独提取出来，与经常迭代的业务代码区别开，这些资源就可以在客户端一直使用缓存。 4）bundle体积监控和分析 为了保证良好的用户体验，我们可以对打包输出的bundle体积进行持续的监控，以防止不必要的冗余模块被添加进来。 VS Code中有一个插件Import Cost可以帮助我们对引入模块的大小进行实时监测。每当我们在代码中引入一个新的模块（主要是node_modules中的模块）时，它都会为我们计算该模块压缩后及gzip过后将占多大体积： 当我们发现某些包过大时就可以采取一些措施，比如寻找一些更小的替代方案或只引用其中的某些子模块。 另外一个很有用的工具是webpack-bundle-analyzer，它能够帮助我们分析一个bundle的构成。 1npm install webpack-bundle-analyzer --save-dev 当前版本webpack-bundle-analyzer 4.4.0； webpack.config.js： 12345678const Analyzer = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;module.exports = &#123; // ... plugins: [ new Analyzer() ]&#125; 执行npm run dev，浏览器打开http://127.0.0.1:8888/，查看生成的bundle的模块组成结构图，每个模块所占的体积一目了然： 最后我们还需要自动化地对资源体积进行监控，bundlesize这个工具包可以做到这一点。 1npm install bundlesize --save-dev 当前版本bundlesize 0.18.1； package.json： 1234567891011121314&#123; // ... &quot;bundlesize&quot;: [ &#123; &quot;path&quot;: &quot;./dist/bundle.js&quot;, &quot;maxSize&quot;: &quot;50 kB&quot; &#125; ], // ... &quot;scripts&quot;: &#123; &quot;test:size&quot;: &quot;bundlesize&quot;, &#125;, // ...&#125; 执行npm run build，dist文件夹生成bundle.js文件，再执行npm run test:size： 九、打包优化主要介绍一些优化Webpack配置的方法，目的是让打包的速度更快，输出的资源更小。首先重述一条软件工程领域的经验——不要过早优化，在项目的初期不要看到任何优化点就拿来加到项目中，这样不但增加了复杂度，优化的效果也不会太理想。一般是当项目发展到一定规模后，性能问题随之而来，这时再去分析然后对症下药，才有可能达到理想的优化效果。 9.1 HappyPackHappyPack是一个通过多线程来提升Webpack打包速度的工具。 9.2 缩小打包作用域9.2.1 exclude和include 9.2.2 noParse有些库我们是希望Webpack完全不要去进行解析的，即不希望应用任何loader规则。 123456module.exports=&#123; // ... module:&#123; noParse:/lodash/, &#125;&#125; 上面的配置将会忽略所有文件名中包含lodash的模块，这些模块仍然会被打包进资源文件，只不过Webpack不会对其进行任何解析。 在Webpack 3及之后的版本还支持完整的路径匹配： 123456789module.exports=&#123; // ... module:&#123; noParse:function(fullPath)&#123; // fullPath是绝对路径，如：/users/me/app/webpack-no-parse/lib/lodash.js return /lib/.test(fullPath); &#125;, &#125;&#125; 上面的配置将会忽略所有lib目录下的资源解析。 9.2.3 IgnorePlugin插件IgnorePlugin完全排除一些模块，被排除的模块即便被引用也不会被打包进资源文件中。 如，Moment.js是一个日期时间处理相关的库，为了做本地化它会加载很多语言包，对于我们来说一般用不到其他地区的语言包，但是它们会占很多体积，这时就可以用IgnorePlugin来去掉。 webpack.config.js： 123456plugins:[ new webpack.IgnorePlugin(&#123; resourceRegExp:/^\\.\\/locale$/, //匹配资源文件 contextRegExp:/moment$/, //匹配检索目录 &#125;)] 9.2.4 Cache有些loader会有一个cache配置项，用来在编译代码后同时保存一份缓存，在执行下一次编译前会先检查源码文件是否有变化，如果没有就直接采用缓存，也就是上次编译的结果。这样相当于实际编译的只有变化了的文件，整体速度会有一定提升。 在Webpack 5中添加了一个新的配置项“cache: { type: “filesystem” }”，它会在全局启用一个文件缓存。该特性仅仅在实验阶段，并且无法自动检测到缓存已经过期。 9.3 动态链接库与DllPlugin动态链接库是早期Windows系统由于受限于当时计算机内存空间较小的问题而出现的一种内存优化方法。当一段相同的子程序被多个程序调用时，为了减少内存消耗，可以将这段子程序存储为一个可执行文件，当被多个程序调用时只在内存中生成和使用同一个实例。 DllPlugin借鉴了动态链接库的这种思路，将vendor完全拆出来，有自己的一整套Webpack配置并独立打包，在实际工程构建时就不用再对它进行任何处理，直接取用即可。 9.4 tree shakingES6 Module依赖关系的构建是在代码编译时而非运行时。基于这项特性Webpack提供了tree shaking功能，它可以在打包过程中帮助我们检测工程中没有被引用过的模块，这部分代码将永远无法被执行到，因此也被称为“死代码”。Webpack会对这部分代码进行标记，并在资源压缩时将它们从最终的bundle中去掉。 tree shaking只能对ES6 Module生效。 如果我们在工程中使用了babel-loader，那么一定要通过配置来禁用它的模块依赖解析。因为如果由babel-loader来做依赖解析，Webpack接收到的都是转化过的CommonJS形式的模块，无法进行tree shaking。 9.5 使用压缩工具去除死代码tree shaking本身只是为死代码添加标记，真正去除死代码是通过压缩工具来进行的。使用terser-webpack-plugin即可。在Webpack 4之后的版本中，将mode设置为production也可以达到相同的效果。 十、开发环境调优10.1 Webpack开发效率插件10.1.1 webpack-dashboardwebpack-dashboard用来更好地展示每次构建结束后在控制台输出的一些打包相关的信息。 1npm install webpack-dashboard --save-dev 当前版本webpack-dashboard 3.3.1； webpack.config.js： 12345678const DashboardPlugin=require(&#x27;webpack-dashboard/plugin&#x27;);module.exports = &#123; // ... plugins: [ new DashboardPlugin(), ]&#125; package.json： 1234&quot;scripts&quot;: &#123; //&quot;dev&quot;: &quot;set ENV=development&amp;&amp; webpack-dev-server&quot;, &quot;dev&quot;: &quot;set ENV=development&amp;&amp; webpack-dashboard -- webpack-dev-server&quot;,&#125;, 10.1.2 webpack-merge假设我们的项目有3种不同的配置，分别对应本地环境、测试环境和生产环境。每一个环境对应的配置都不同，但也有一些公共的部分，那么将公共的部分提取出来，创建一个webpack.common.config.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* eslint-disable indent *//* eslint-disable no-undef */const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);const Analyzer = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;const DashboardPlugin=require(&#x27;webpack-dashboard/plugin&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, devtool: &#x27;source-map&#x27;, optimization: &#123; minimize: true, &#125;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; sourceMap: true, &#125; &#125;, &#x27;postcss-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, publicPath: &#x27;/&#x27;, &#125; &#125; &#125;, &#123; test: /\\.(js|jsx)$/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, //缓存机制, 重复打包未改变的模块防止二次编译 presets: [ [ &#x27;@babel/env&#x27;, &#123; modules: false, //禁用模块语句的转化, 将ES6 Module的语法交给Webpack本身处理 &#125; ], [ &#x27;@babel/preset-react&#x27;, &#123; modules: false, &#125; ] ], &#125; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125; ] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;, plugins: [ ////输出动态HTML new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27; &#125;), ////生成bundle模块组成结构图 new Analyzer(), ////更好地展示打包信息 new DashboardPlugin(), ]&#125; 每一个环境都有一个相应的配置文件，对于生产环境可以专门创建一个webpack.prod.config.js： 123456/* eslint-disable no-undef */const commonConfig = require(&#x27;./webpack.common.config.js&#x27;);module.exports = Object.assign(commonConfig, &#123; mode: &#x27;production&#x27;&#125;); 现在本地测试使用webpack-dev-server，file-loader的publicPath设置为根目录“/”，而执行npm run build打包的图片保存在dist文件夹下，因此需要在webpack.prod.js中重新设置。 如果通过Object.assign无法准确找到CSS的规则并进行替换，所以必须替换整个module的配置。 但我们可以通过webpack-merge解决这个问题。它在合并module.rules的过程中会以test属性作为标识符，当发现有相同项出现的时候会以后面的规则覆盖前面的规则，这样就不必添加冗余代码了。 1npm install webpack-merge --save-dev 当前版本webpack-merge 5.7.3； webpack.prod.config.js： 123456789101112131415161718192021/* eslint-disable no-undef */const commonConfig = require(&#x27;./webpack.common.config.js&#x27;);const &#123; merge &#125;=require(&#x27;webpack-merge&#x27;);module.exports = merge(commonConfig, &#123; mode: &#x27;production&#x27;, module:&#123; rules:[ &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, publicPath: &#x27;/dist/&#x27;, &#125; &#125; &#125; ] &#125;&#125;); webpack.dev.config.js： 123456789101112131415161718192021222324/* eslint-disable no-undef */const commonConfig = require(&#x27;./webpack.common.config.js&#x27;);// webpack-merge v5 (and later)const &#123; merge &#125;=require(&#x27;webpack-merge&#x27;);// webpack-merge v4 (and earlier)//const merge = require(&#x27;webpack-merge&#x27;);module.exports = merge(commonConfig, &#123; mode: &#x27;development&#x27;, module:&#123; rules:[ &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, publicPath: &#x27;/&#x27;, &#125; &#125; &#125; ] &#125;&#125;); webpack.common.config.js： 12345678910111213141516module.exports = &#123; // ... module:&#123; rules:[&#123; ////配置在开发和生产环境各自的配置文件中(注释以下内容) // test: /\\.(png|svg|jpg|gif)$/, // use: &#123; // loader: &#x27;file-loader&#x27;, // options: &#123; // name: &#x27;[name].[ext]&#x27;, // publicPath: &#x27;/dist/&#x27;, // &#125; // &#125; &#125;] &#125;&#125;; package.json： 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --config=webpack.prod.config.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config=webpack.dev.config.js&quot;,&#125;, 分别执行npm run dev或npm run build，进行验证； 10.1.3 speed-measure-webpack-plugin觉得Webpack构建很慢但又不清楚如何优化？可以试试speed-measure-webpack-plugin插件（简称SMP）。SMP可以分析出Webpack整个打包过程中在各个loader和plugin上耗费的时间，这将会有助于找出构建过程中的性能瓶颈。 10.1.4 size-pluginsize-plugin这个插件会帮助我们监控资源体积的变化，会输出本次构建的资源体积，以及与上次构建相比体积变化了多少。 10.2 模块热替换HMR一些Web开发框架和工具只要检测到代码改动就会自动重新构建，然后触发网页刷新，这种一般称为live reload。 Webpack则在live reload的基础上又进一步，可以让代码在网页不刷新的前提下得到最新的改动，甚至不需要重新发起请求就能看到更新后的效果，这就是模块热替换功能（Hot Module Replacement，HMR）。 10.2.1 开启HMRHMR是需要手动开启的，并且有一些必要条件。 首先我们要确保项目是基于webpack-dev-server或webpack-dev-middle进行开发的，Webpack本身的命令行并不支持HMR。 调用HMR API有两种方式，一种是手动添加这部分代码；另一种是借助一些现成的工具，如react-hot-loader、vue-loader等。 ===》一种是，手动添加代码： 123456import &#123; add &#125; from &#x27;util.js&#x27;;add(2,3);if(module.hot)&#123; module.hot.accept();&#125; ===》另一种是，第三方提供的HMR，react组件的热更新由react-hot-loader处理 10.2.2 HMR原理 当你对代码修改并保存后，webpack将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。 在本地开发环境下，浏览器是客户端，webpack-dev-server（WDS）相当于我们的服务端。HMR的核心就是客户端从服务端拉取更新后的资源（准确地说，HMR拉取的不是整个资源文件，而是chunk diff，即chunk需要更新的部分） 第一步，浏览器什么时候去拉取这些更新，这需要WDS对本地源文件进行监听。实际上WDS与浏览器之间维护了一个websocket，当本地资源发生变化时WDS会向浏览器推送更新事件，并带上这次构建的hash，让客户端与上一次资源进行比对。通过hash的比对可以防止冗余更新的出现。 下一步，要知道拉取什么。在刚刚的websocket中，客户端已经知道新的构建结果和当前有差别，就会向WDS发起一个请求（这个请求名字为[hash].hot-update）来获取更新文件的列表，即哪些模块有改动。 十一、其他JavaScript打包工具11.1 Rollup如果当前的项目需求仅仅是打包Javascript，Rollup是我们的第一选择。 11.2 Parcel 十二、(附加)自动清除上一次打包的文件1npm install clean-webpack-plugin --save-dev 当前版本clean-webpack-plugin 3.0.0； webpack.common.config.js： 12345678const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123; // ... plugins: [ new CleanWebpackPlugin(), ]&#125; 执行npm run build，验证结果，出现以下两个问题： Q1：clean-webpack-plugin: options.output.path not defined. Plugin disabled…打包清除不了之前的文件 12345678910111213// webpack.common.config.jsconst &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123; // ... output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(process.cwd(), &#x27;dist&#x27;), //必须配置这行代码，否则无法删除/dist/目录中的文件(写法不止一种) &#125;, plugins: [ new CleanWebpackPlugin(), ]&#125; Q2：Error: EPERM: operation not permitted, lstat ‘D:\\LearnCode\\learn_react_webpack\\dist\\images\\hexo-deploy.png’ 123456789101112131415// webpack.common.config.jsconst &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123; // ... output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(process.cwd(), &#x27;dist&#x27;), //必须配置这行代码，否则无法删除/dist/目录中的文件(写法不止一种) &#125;, plugins: [ new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: [&#x27;./dist/*&#x27;] //配置./dist/*或./dist/images/*,测试无差别(20210302) &#125;), ]&#125; 十三、代码备份github链接地址：https://github.com/YuliaScott/learn_react_webpack 1234下载压缩包或克隆项目解压执行 npm install（安装项目包文件）执行 npm run dev 或 npm run build （第二部分完）","categories":[{"name":"技术读物","slug":"技术读物","permalink":"https://yuliascott.github.io/blog/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yuliascott.github.io/blog/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yuliascott.github.io/blog/tags/Webpack/"}],"keywords":[{"name":"技术读物","slug":"技术读物","permalink":"https://yuliascott.github.io/blog/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/"}]},{"title":"Webpack实战(1)-居玉皓著","slug":"Webpack实战(1)-居玉皓著","date":"2021-03-12T11:06:48.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"技术读物/Webpack实战(1)-居玉皓著/","link":"","permalink":"https://yuliascott.github.io/blog/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/Webpack%E5%AE%9E%E6%88%98(1)-%E5%B1%85%E7%8E%89%E7%9A%93%E8%91%97/","excerpt":"","text":"基于《Webpack实战 入门、进阶与调优》学习Webpack，搭建学习demo，共两个部分，本文是第一部分。 一、Webpack简介Webpack 核心概念： Entry（入口）：Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入 Output（出口）：指示 webpack 如何去输出、以及在哪里输出 Module（模块）：在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块 Chunk（代码块）：一个 Chunk 由多个模块组合而成，用于代码合并与分割 Loader（模块转换器）：用于把模块原内容按照需求转换成新内容 Plugin（扩展插件）：在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件，并改变输出结果 二、安装2.1 创建工程目录learn_react_webpack 2.2 进入该目录，执行npm初始化命令1npm init #若使用yarn，则yarn init 输入项目基本信息，最后在目录中生成了一个package.json文件，它相当于npm项目的说明书，里面记录了项目名称、版本、仓库地址等信息 2.3 执行安装webpack的命令1npm install webpack webpack-cli --save-dev 1. webpack是核心模块，webpack-cli是命令行工具； 2. 当前安装webpack 5.23.0，webpack-cli 3.3.12； 2.4 打包第一个应用2.4.1 在工程目录下添加文件文件目录如下： 12345678910learn_react_webpack/dist/ bundle.jsnode_modules/ public/ index.html src/ App.js index.js package.json App.js： 123export default function()&#123; document.write(&#x27;Hello world!!&#x27;);&#125; index.js： 123import App from &#x27;./App&#x27;;document.write(&#x27;This is index file.&lt;br/&gt;&#x27;);App(); index.html： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;learn react webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;/dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.4.2 使用npm scripts编辑工程中的package.json文件，添加脚本命令： 123&quot;scripts&quot;: &#123; &quot;build&quot;:&quot;webpack --entry=./src/index.js --output-filename=bundle.js --mode=development&quot;,&#125;, 1. entry：资源打包入口，webpack默认的源代码入口就是src/index.js，因此可以省略entry配置 2. output-filename：输出资源名 3. mode：打包模式，development、production、none三种模式 2.4.3 执行打包输入npm build，打开index.html页面验证 2.4.4 使用配置文件使用npx webpack -h，查看webpack的配置项以及相对应的命令行参数。 当项目需要越来越多的配置时，将这些命令行参数改为对象的形式专门存放在一个配置文件里。Webpack的默认配置文件为webpack.config.js。 1）在工程根目录下创建webpack.config.js，添加如下代码： 1234567module.exports=&#123; entry:&#x27;./src/index.js&#x27;, output:&#123; filename:&#x27;bundle.js&#x27;, &#125;, mode:&#x27;development&#x27;&#125; 2）去掉package.json中配置的打包参数： 123&quot;scripts&quot;: &#123; &quot;build&quot;:&quot;webpack&quot;,&#125;, 3）为了验证效果，修改App.js内容 123export default function()&#123; document.write(&#x27;using a config file!!&#x27;);&#125; 4）执行npm run build，Webpack就会预先读取webpack.config.js，然后进行打包，最后打开index.html进行验证 2.4.5 webpack-dev-server每次修改完源代码都要执行npm run build更新bundle.js，然后刷新页面才能生效，有没有简便的方法呢？ 本地开发工具——webpack-dev-server，可以提高开发调试效率。 1npm install webpack-dev-server --save-dev 1）在package.json中添加dev命令 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot;,&#125;, 2）编辑webpack.config.js文件，配置webpack-dev-server 123456789101112module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, mode: &#x27;development&#x27;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定 bundle 的来源，并具有优先级高于 contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 3）修改App.js内容 123export default function()&#123; document.write(&#x27;using webpack-dev-server!!&#x27;);&#125; 4）修改index.html内容 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;learn react webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; //如果设置了publicPath，要以publicPath作为路径&lt;/body&gt;&lt;/html&gt; 5）执行npm run dev，打开http://localhost:8080/ webpack-dev-server配置时遇到的问题： Q1：Cannot get / 执行npm run dev后，页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就会显示cannot get /，因此，contentBase设置的值是index.html所在的文件目录。 Q2：没有展示页面内容，只显示了一个目录视图 如果contentBase参数设置不对的话，会展示一个以该参数指定目录作为根目录的路由窗口，contentBase设置到为index.html。如果设置了publicPath，index.html中的src也要以publicPath作为路径。 =====》由于文件直接打包在/dist文件夹根目录下，因此publicPath不用设置，最终配置如下： 三、类型模块CommonJS ES6 Module AMD UMD 3.1 CommonJS和ES6 Module形式3.1.1 模块 CommonJS： 1234567//app.jsvar name=&#x27;app.js&#x27;;//index.jsvar name=&#x27;index.js&#x27;;require(&#x27;./app.js&#x27;);console.log(name); //index.js, app.js中的变量声明不会影响index.js, 每个模块拥有各自的作用域 ES6 Module： 123456789101112//app.jsexport default&#123; name:&#x27;app.js&#x27;, add:function(a, b)&#123; return a + b; &#125;&#125;//index.jsimport app from &#x27;./app.js&#x27;;const sum=app.add(2,3);console.log(sum); //5 3.1.2 导入 CommonJS： 1234567891011//app.jsmodule.exports=&#123; add:function(a,b)&#123; return a + b; &#125;&#125;//index.jsconst app=require(&#x27;./app.js&#x27;);const sum=app.add(2,3);console.log(sum); //5 注意：当我们require一个模块时会有两种情况： 1. require的模块是第一次被加载。这时会首先执行该模块，然后导出内容； 2. require的模块曾被加载过。这时该模块的代码不会再次执行，而是直接导出上次执行后得到的结果 ES6 Module： 12345678//app.jsconst name=&#x27;app.js&#x27;;const add=function(a,b)&#123; return a + b &#125;;export &#123; name , add &#125;;//index.jsimport &#123;name,add as calculateSum&#125; from &#x27;./app.js&#x27;;calculateSum(2,3); 3.1.3 导出 CommonJS： 12345678910111213module.exports=&#123; name:&#x27;app.js&#x27;, add:function(a,b)&#123; return a + b; &#125;&#125;或exports.name=&#x27;app.js&#x27;;exports.add=function(a, b)&#123; return a + b;&#125; 注意：module.exports 和 exports 不能混用 ES6 Module： 12345678export const name=&#x27;app.js&#x27;;export const add=function(a,b)&#123;return a + b&#125;;或const name=&#x27;app.js&#x27;;const add=function(a,b)&#123;return a + b&#125;;export &#123; name,add as getSum &#125;; 3.2 CommonJS和ES6 Module区别3.2.1 动态与静态CommonJS和ES6 Module最本质的区别在于前者对模块依赖的解决是“动态的”，而后者是“静态的”。这里的“动态”是模块依赖关系的建立发生在代码运行阶段；而“静态”则是模块依赖关系的建立发生在代码编译阶段。 require的模块路径可以动态指定，支持传入一个表达式，甚至通过if语句判断是否加载某个模块，因此CommonJS模块被执行前，没办法确定明确的依赖关系。 ES6 Module的导入、导出语句都是声明式的，不支持导入的路径是一个表达式，并且导入、导出语句必须位于模块的顶层作用域，相比于CommonJS具备以下优势： 死代码检测和排除。可以用静态分析工具检测出哪些模块没有被调用过。 模块变量类型检查。确保模块之间传递的值或接口类型是正确的。 编译器优化。在CommonJS等动态模块系统中，本质上导入的都是一个对象，而ES6 Module支持直接导入变量，减少引用层级。 3.2.2 值拷贝与动态映射CommonJS是一份导出值的拷贝；ES6 Module则是值的动态映射，这个映射是只读的。 CommonJS： 12345678910111213141516171819//app.jsvar count = 0;module.exports = &#123; count: count, add: function (a, b) &#123; return a + b; &#125;&#125; //index.jsvar count=require(&#x27;./App.js&#x27;).count;var add=require(&#x27;./App.js&#x27;).add;console.log(count); //0，对App.js中count值的拷贝add(2,3);console.log(count); //0，App.js中变量值的改变不会对这里的拷贝值有影响count+=1;console.log(count); //1，拷贝值可以更改 ES6 Module： 1234567891011121314151617//app.jslet count = 0;const add = function (a, b) &#123; count += 1; return a + b;&#125;;export &#123; count, add &#125;;//index.jsimport &#123; count, add &#125; from &#x27;./App&#x27;;console.log(count); //0, 对app.js中count值的映射add(2, 3);console.log(count); //1, 实时反映app.js中count值的变化count += 1; //Uncaught TypeError: Cannot set property count of #&lt;Object&gt; which has only a getter 2.3 循环依赖 3.3 AMD（异步模块定义）使用define函数定义模块，接受3个参数： 第1个参数当前模块的id，相当于模块名； 第2个参数是当前模块的依赖，如getSum模块需要引入app模块作为依赖； 第3个参数用来描述模块的导出值，可以是函数或对象。如果是函数则导出的是函数的返回值；如果是对象则直接导出对象本身。 12345define(&#x27;getSum&#x27;,[&#x27;app&#x27;],function(math)&#123; return function(a,b)&#123; console.log(&#x27;sum:&#x27;+app.add(a,b)); &#125;&#125;); 3.4 UMD（通用模块标准） 四、资源输入输出4.1 资源处理流程Webpack会从入口文件开始检索，将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物称之为bundle（束）。entry、chunk、bundle的关系如图： 在工程中可以定义多个入口，每个入口都会产生一个结果资源，entry和bundle存在着对应关系： 4.2 配置资源12345678910111213module.exports=&#123; context:path.join(__dirname,&#x27;./src&#x27;), entry:&#123; app:&#x27;app.js&#x27;, page:&#x27;page.js&#x27;, //演示多入口, 每个页面都有一个独立的bundle vendor:[&#x27;react&#x27;,&#x27;react-dom&#x27;,&#x27;react-router&#x27;], &#125;, output:&#123; filename:&#x27;[name].js&#x27;, path:path.join(__dirname,&#x27;./dist&#x27;), publicPath:&#x27;/assets/&#x27;, &#125; &#125; 配置资源入口： 1. context：资源入口的路径前缀；可以省略，默认值为当前工程的根目录； 2. entry：支持多种形式：字符串、数组、对象、函数； 3. vendor：一般指的是工程所使用的库、框架等第三方模块集中打包而产生的bundle； 配置资源出口： 1. filename：输出资源的文件名，形式为字符串，不仅可以是bundle的名字，还可以是一个相对路径。路径中的目录不存在，Webpack会自动创建该目录；模板变量支持[hash]、[chunkhash]、[id]、[query]； 2. path：指定资源输出的位置，Webpack 4之后，output.path默认为dist目录； 3. publicPath：由JS或CSS所请求的间接资源路径； 五、预处理器Webpack本身只认识JavaScript，对于其他类型的资源(CSS、图片、字体等)必须预先定义一个或多个loader对其进行转译，输出为Webpack能够接收的形式再继续进行，因此loader实际上是一个预处理的工作。 5.1 css-loader：处理CSS的各类加载语法将css-loader添加到工程中： 1npm install css-loader style-loader 1. css-loader的作用仅仅是处理CSS的各种加载语法（@import和url()函数等），如果要使样式起作用还需要style-loader将样式插入页面； 2. 当前安装css-loader 5.0.2，style-loader 2.0.0； App.css： 123.app&#123; background: red;&#125; App.js： 12345import &#x27;./App.css&#x27;;export default function()&#123; document.write(&#x27;&lt;div class=&quot;app&quot;&gt;Hello world!!&lt;/div&gt;&#x27;);&#125; index.js： 1234import App from &#x27;./App&#x27;;document.write(&#x27;This is index file.&lt;br/&gt;&#x27;);App(); webpack.config.js： 12345678910111213141516171819module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, mode: &#x27;development&#x27;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定 bundle 的来源，并具有优先级高于 contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 1. css-loader与style-loader通常是配合在一起使用，style-loader用来将样式字符串包装成style标签插入到页面； 2. 因为Webpack打包时是按照数组**从后往前**的顺序将资源交给loader处理的，因此style-loader加到css-loader前面； 3. exclude和include同时存在时，exclude的优先级更高；（*[*配置参考*](https://survivejs.com/webpack/loading/loader-definitions/)*） 4. resource和issuer，resource是被加载模块，issuer是加载者； 5. enforce用来指定一个loader的种类，只接收“pre”和“post”两种字符串类型的值； ———————————————————————————————————————————————— eslint：开源的JavaScript的linting工具，用来检查代码质量问题和统一代码风格。 安装命令： 12345npm install eslint eslint-loader --save-dev# oryarn add eslint eslint-loader --dev 当前版本eslint 7.20.0，eslint-loader 4.0.2，eslint-plugin-react 7.22.0； 初始化命令： 12345npx eslint --init# oryarn run eslint --init 执行完成（这里选择当前项目不使用typescript），选择json格式，生成.eslintrc.json文件； .eslintrc.json： 1234567891011121314151617181920212223&#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es2021&quot;: true &#125;, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:react/recommended&quot; ], &quot;parserOptions&quot;: &#123; &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125;, &quot;ecmaVersion&quot;: 12, &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;plugins&quot;: [ &quot;react&quot; ], &quot;rules&quot;: &#123; &quot;indent&quot;: [&quot;error&quot;, 4] //打开规则作为一个错误; 首字母缩进4个字符 &#125;&#125; webpack.config.js： 12345678910111213141516171819202122232425262728293031/* eslint-disable no-undef */let ENV = process.env.ENV;let isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;bundle.js&#x27;, &#125;, mode: ENV, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#x27;file-loader&#x27;, &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; App.js： 12345import &#x27;./App.css&#x27;;export default function () &#123; document.write(&#x27;&lt;div class=&quot;app&quot;&gt;Hello world!!&lt;/div&gt;&#x27;);&#125; ———————————————————————————————————————————————— 设置的规则是“首字母缩进4个字符”，故意删除App.js中的首字母缩进，有两种方式解决： ===》VS Code安装ESLint插件，快捷键shift+Alt+f格式化； ===》eslint –fix命令： 123&quot;scripts&quot;: &#123; &quot;esfix&quot;:&quot;yarn eslint --fix --ext .js ./src&quot;&#125;, 执行yarn run esfix，查看App.js代码格式是否修复 5.2 babel-loader：处理ES6+编译为ES5安装react命令： 1npm install react react-dom --save index.html： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;learn react webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;webapp&quot;&gt; hello webpack &lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js： 12345678910111213import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;import hexoimg from &#x27;./images/hexo-deploy.png&#x27;;ReactDOM.render( &lt;&gt; &lt;div&gt;Hello React!&lt;/div&gt; &lt;img src=&#123;hexoimg&#125; /&gt; &lt;App /&gt; &lt;/&gt;, document.getElementById(&#x27;webapp&#x27;)); App.js： 1234567891011121314import React from &#x27;react&#x27;;import &#x27;./App.css&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;app&quot;&gt; 这是App组件！ &lt;/div&gt; ); &#125;&#125;export default App; 执行npm run dev，出现错误： 因为使用了react，react是使用jsx语法实现的，而jsx不能直接被浏览器识别和执行，所以这里需要引入Babel库进行转码。 1npm install babel-loader @babel/core @babel/preset-env @babel/preset-react 1. 当前版本babel-loader 8.2.2，@babel/core 7.13.1，@babel/preset-env 7.13.5，@babel/preset-react 7.12.13； 2. 各个模块的作用： babel-loader：它会使Babel与Webpack协同工作的模块； @babel/core：它是Babel编译器的核心模块； @babel/preset-env：它是Babel官方推荐的预置器，可根据用户设置的目标环境自动添加所需的插件和补丁来编译ES6+代码； webpack.config.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* eslint-disable no-undef */let ENV = process.env.ENV;let isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;bundle.js&#x27;, &#125;, mode: ENV, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, publicPath: &#x27;/&#x27;, &#125; &#125; &#125;, &#123; test: /\\.(js|jsx)$/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, //缓存机制, 重复打包未改变的模块防止二次编译 presets: [[ &#x27;@babel/env&#x27;, &#123; modules: false, //禁用模块语句的转化, 将ES6 Module的语法交给Webpack本身处理 &#125; ], [ &#x27;@babel/preset-react&#x27;, &#123; modules: false, &#125; ]], &#125; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 执行npm run dev，验证结果： 5.3 file-loader：打包文件类型的资源，并返回其publicPath1）安装命令 1npm install file-loader 当前版本file-loader 6.2.0； 文件目录结构： 123456789101112learn_react_webpack/dist/ bundle.jsnode_modules/ public/ index.html src/ images/ hexo-deploy.png App.js index.js package.json index.js： 123456import App from &#x27;./App&#x27;;import hexoimg from &#x27;./images/hexo-deploy.png&#x27;;document.write(&#x27;This is index file.&lt;br/&gt;&#x27;);document.write(&#x27;&lt;img src=&#x27; + hexoimg + &#x27;&gt;&#x27;);App(); webpack.config.js： 12345678910111213141516171819202122module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, mode: &#x27;development&#x27;, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#x27;file-loader&#x27;, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定 bundle 的来源，并具有优先级高于 contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 2）执行npm run dev，打开index.html验证结果； 以上配置没有指定output.publicPath，因此打印出的图片路径只是文件名，默认为文件的hash值加上文件后缀。 ===》添加output.publicPath： 1234567891011121314151617181920212223242526272829303132/* eslint-disable no-undef */let ENV = process.env.ENV;let isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;bundle.js&#x27;, publicPath: &#x27;/&#x27; &#125;, mode: ENV, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#x27;file-loader&#x27;, &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; index.js： 1234567import App from &#x27;./App&#x27;;import hexoimg from &#x27;./images/hexo-deploy.png&#x27;;document.write(&#x27;This is index file.&lt;br/&gt;&#x27;);document.write(&#x27;&lt;img src=&#x27; + hexoimg + &#x27;&gt;&#x27;);console.log(hexoimg);App(); 执行npm run dev，此时图片路径变成以下形式： ===》file-loader支持配置文件名以及publicPath： 123456789101112rule:[ &#123; test: /\\.(png|svg|jpg|gif)$/, use:&#123; loader:&#x27;file-loader&#x27;, options:&#123; name:&#x27;[name].[ext]&#x27;, publicPath:&#x27;/&#x27;, &#125; &#125; &#125;] index.js： 1234567import App from &#x27;./App&#x27;;import hexoimg from &#x27;./images/hexo-deploy.png&#x27;;document.write(&#x27;This is index file.&lt;br/&gt;&#x27;);document.write(&#x27;&lt;img src=&#x27; + hexoimg + &#x27;&gt;&#x27;);console.log(hexoimg);App(); 执行npm run dev，此时图片路径变成以下形式： 5.4 url-loader：作用与file-loader类似不同在于设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath，而小于该阈值时返回文件base64形式编码。 1npm install url-loader 当前版本url-loader 4.1.1； webpack.config.js： 1234567891011121314151617181920212223242526272829303132333435363738/* eslint-disable no-undef */let ENV = process.env.ENV;let isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;bundle.js&#x27;, &#125;, mode: ENV, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;,&#123; test: /\\.(png|svg|jpg|gif)$/, use:&#123; loader:&#x27;url-loader&#x27;, options:&#123; limit:102400, name:&#x27;[name].[ext]&#x27;, publicPath:&#x27;/&#x27;, &#125; &#125; &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; index.js： 1234567import App from &#x27;./App&#x27;;import hexoimg from &#x27;./images/hexo-deploy.png&#x27;;document.write(&#x27;This is index file.&lt;br/&gt;&#x27;);document.write(&#x27;&lt;img src=&#x27; + hexoimg + &#x27;&gt;&#x27;);console.log(hexoimg);App(); 执行npm run dev，此时图片路径变成以下形式： 5.5 自定义loader比如我们将实现一个loader，它会为所有JS文件启用严格模式，也就是说它会在文件头部加上如下代码： 1&#x27;use strict&#x27; 在开发一个loader时，我们可以借助npm/yarn的软链功能进行本地调试（可以考虑发布到npm等）。下面初始化这个loader并配置到工程中。 创建一个force-strict-loader目录，然后在该目录下执行npm初始化命令。 1npm init -y 接着创建index.js，也就是loader的主体： 1234module.exports = function(content)&#123; var useStrictPrefix = &#x27;\\&#x27;use strict\\&#x27;;\\n\\n&#x27;; return useStrictPrefix + content;&#125; 现在可以在Webpack工程中安装并使用这个loader： 1npm install &lt;path-to-loader&gt;/force-strict-loader 在Webpack工程目录下使用相对路径安装，会在项目的node_modules中创建一个指向实际force-strict-loader目录的软链，也就是之后可以随时修改loader源码并且不需要重复安装。 修改Webpack配置： 12345678module: &#123; rules: [ &#123; test:&#x27;/\\.js$/&#x27;, use:&#x27;force-strict-loader&#x27;, &#125; ]&#125; 这个loader设置为对所有JS文件生效。此时对该工程进行打包，可以看到JS文件的头部都已经加上了启用严格模式的语句。 六、样式处理6.1 分离样式文件使用style-loader和css-loader打包JS引用CSS的样式，如果使用style标签方式引入样式，如何输出单独的CSS文件呢？ extract-text-webpack-plugin：适用于Webpack 4之前版本 mini-css-extract-plugin：适用于Webpack 4及以上版本 6.2 样式预处理样式预编译语言： SCSS Less 6.3 PostCSSPostCSS是一个用JS工具和插件转换 CSS 代码的工具。它的工作模式是接收样式源代码并交由编译插件处理，最后输出CSS。 1npm install postcss-loader 当前版本postcss-loader 5.0.0； webpack.config.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* eslint-disable no-undef */let ENV = process.env.ENV;let isProd = ENV === &#x27;production&#x27;;module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: isProd ? &#x27;bundle@[chunkhash].js&#x27; : &#x27;bundle.js&#x27;, &#125;, mode: ENV, module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;,&#x27;postcss-loader&#x27;], exclude: /node_modules/, //node_modules中的模块不会执行这条规则 #/src\\/pages/ &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[ext]&#x27;, publicPath: &#x27;/&#x27;, &#125; &#125; &#125;, &#123; test: /\\.(js|jsx)$/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, //缓存机制, 重复打包未改变的模块防止二次编译 presets: [[ &#x27;@babel/env&#x27;, &#123; modules: false, //禁用模块语句的转化, 将ES6 Module的语法交给Webpack本身处理 &#125; ], [ &#x27;@babel/preset-react&#x27;, &#123; modules: false, &#125; ]], &#125; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, use: &#x27;eslint-loader&#x27;, enforce: &#x27;pre&#x27;, exclude: /node_modules/, &#125;] &#125;, devServer: &#123; // publicPath: &#x27;/&#x27;, //用于确定bundle的来源，并具有优先级高于contentBase contentBase: &#x27;./public&#x27;, //页面打开的url是以devServer中的contentBase作为当前查询目录，只要文档不在contentBase所指定的目录中，就只会显示cannot get hot: true &#125;&#125; 在项目的根目录下创建一个postcss.config.js： 12/* eslint-disable no-undef */module.exports=&#123;&#125;; 6.3.1 Autoprefixer自动前缀根据caniuse.com上的数据，自动决定是否要为某一特性添加厂商前缀，由开发者为其指定支持浏览器的范围。 1npm install autoprefixer 当前版本autoprefixer 10.2.4； 在postcss.config.js中添加autoprefixer： 12345678910111213141516/* eslint-disable no-undef */const autoprefixer = require(&#x27;autoprefixer&#x27;);module.exports = &#123; plugins: [ autoprefixer(&#123; grid: true, overrideBrowserslist: [ &#x27;&gt;1%&#x27;, &#x27;last 3 versions&#x27;, &#x27;android 4.2&#x27;, &#x27;ie 8&#x27; ] &#125;) ]&#125;; App.css： 1234567.container &#123; display: grid;&#125;.app &#123; background: red;&#125; App.js： 12345678910111213141516import React from &#x27;react&#x27;;import &#x27;./App.css&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;app&quot;&gt; 这是App组件！ &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 执行npm run dev，进行验证： 当前测试浏览器 Chrome 88.0.4324.182（正式版本） （64 位） 6.3.2 stylelint质量检查工具stylelint是一个CSS的质量检测工具，就像eslint一样，为其添加各种规则，来统一项目的代码风格，确保代码质量。 1npm install stylelint 当前版本stylelint 13.11.0； postcss.config.js： 123456789101112131415161718192021222324/* eslint-disable no-undef */const autoprefixer = require(&#x27;autoprefixer&#x27;);const stylelint = require(&#x27;stylelint&#x27;);module.exports = &#123; plugins: [ autoprefixer(&#123; grid: true, overrideBrowserslist: [ &#x27;&gt;1%&#x27;, &#x27;last 3 versions&#x27;, &#x27;android 4.2&#x27;, &#x27;ie 8&#x27; ] &#125;), stylelint(&#123; config: &#123; rules: &#123; &#x27;declaration-no-important&#x27;: true &#125; &#125; &#125;) ]&#125;; App.css： 1234567.container &#123; display: grid;&#125;.app &#123; background: red !important;&#125; App.js： 12345678910111213141516import React from &#x27;react&#x27;;import &#x27;./App.css&#x27;;class App extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;app&quot;&gt; 这是App组件！ &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 执行npm run dev，进行验证： 6.3.3 CSSNextPostCSS与CSSNext结合使用，在应用中使用最新的CSS语法特性。 1npm install postcss-cssnext 当前版本postcss-cssnext 3.1.0； postcss.config.js： 12345678910111213141516171819202122232425262728293031/* eslint-disable no-undef */const autoprefixer = require(&#x27;autoprefixer&#x27;);const stylelint = require(&#x27;stylelint&#x27;);const postcssCssnext=require(&#x27;postcss-cssnext&#x27;);module.exports = &#123; plugins: [ autoprefixer(&#123; grid: true, overrideBrowserslist: [ &#x27;&gt;1%&#x27;, &#x27;last 3 versions&#x27;, &#x27;android 4.2&#x27;, &#x27;ie 8&#x27; ] &#125;), stylelint(&#123; config: &#123; rules: &#123; &#x27;declaration-no-important&#x27;: true &#125; &#125; &#125;), postcssCssnext(&#123; overrideBrowserslist: [ &#x27;&gt;1%&#x27;, &#x27;last 2 versions&#x27;, ] &#125;) ]&#125;; App.css： 123456789101112:root &#123; --fontFamily: &quot;Times New Roman&quot;;&#125;.container &#123; display: grid;&#125;.app &#123; background: red; /* !important; */ font-family: var(--fontFamily);&#125; 执行npm run dev，验证结果： 备注：执行npm run dev，终端显示： 因此注释postcss.config.js中的autoprefixer配置，重新执行： 6.4 CSS ModulesCSS Modules将CSS模块化： 每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突； 对CSS进行依赖管理，可以通过相对路径引入CSS文件； 可以通过composes轻松复用其他CSS模块； 使用CSS ModulesCSS文件会导出一个对象： 12345678//style.css.title&#123; color:red;&#125;//app.jsimport styles from &#x27;./style.css&#x27;;document.write(&#x27;&lt;h1 class=`$&#123;styles.title&#125;`&gt;my webpack app.&lt;/h1&gt;&#x27;); （第一部分完）","categories":[{"name":"技术读物","slug":"技术读物","permalink":"https://yuliascott.github.io/blog/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yuliascott.github.io/blog/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://yuliascott.github.io/blog/tags/Webpack/"}],"keywords":[{"name":"技术读物","slug":"技术读物","permalink":"https://yuliascott.github.io/blog/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/"}]},{"title":"Nginx部署Hexo并配置域名","slug":"nginx部署hexo并配置域名","date":"2021-01-06T15:13:48.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"工具教程/nginx部署hexo并配置域名/","link":"","permalink":"https://yuliascott.github.io/blog/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/nginx%E9%83%A8%E7%BD%B2hexo%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%9F%9F%E5%90%8D/","excerpt":"","text":"使用nginx部署博客网站，并在国外网站(cloudflare)配置域名解析。 ###写在前面 本文的内容全部基于《搭建个人博客网站》 为确保网站运行正常，除了基于github外，又使用Nginx服务器部署，网站内容完全相同 Nginx服务器绑定的域名是www.example.com，基于github绑定的域名是blog.example.com，并且都支持https（本文不涉及cloudflare如何申请https密钥和github如何设置使用https） 先前Nginx服务器运行在腾讯云 window server 2019（nginx为1.18.0稳定版），且阿里云购买的域名，域名解析也在阿里云，后来网站无法运行，提示需要域名备案 域名备案过程中，提示“备案和云服务器提供商必须一致”。有两种方式解决：1）购买腾讯云服务器，平时服务器使用不多，不打算购买；2）将阿里云域名转入腾讯云，不过域名需强制续费一年，但我使用的是朋友的腾讯云，备案实名认证多少有些不方便。最后我选择在GoDaddy购买域名，cloudflare进行域名解析，与此同时，我有一台VPS服务器(购买的是伦敦的，ubuntu) Nginx服务器运行在ubuntu，静态页面保存在根目录/web/public目录 一、Nginx配置1、配置http网站 1）XShell远程连接ubuntu，Xftp可视化操作ubuntu文件夹，在根目录(/)新建文件夹web； 2）执行yarn build，生成的public文件夹保存到web目录下，静态页面保存的路径是/web/public 3）编辑/etc/nginx/nginx.conf文件： 12345678910111213141516171819202122server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; root /web/public; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; root /web/public; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 2、配置https 1）在cloudflare上申请https 密钥（申请过程省略），即生成两个PEM密钥文件 2）在/etc/nginx路径下新建文件夹conf.d，再新建文件夹cert（即/etc/nginx/conf.d/cert），将生成的PEM文件放在该路径下 3）编辑/etc/nginx/nginx.conf文件： 123456789101112131415161718192021222324252627282930# Settings for a TLS enabled server.#server &#123; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name _; root /web/public; #/usr/share/nginx/html; ssl_certificate &quot;/etc/nginx/conf.d/cert/cert.pem&quot;; #&quot;/etc/pki/nginx/server.crt&quot;; ssl_certificate_key &quot;/etc/nginx/conf.d/cert/key.pem&quot;; #&quot;/etc/pki/nginx/private/server.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers PROFILE=SYSTEM; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; root /web/public; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; ———————————————————————————————————————————————————————————————————————————————— 二、配置域名解析输入www.example.com或example.com或blog.example.com，可同时访问。 ———————————————————————————————————————————————————————————————————————————————— 附：国外域名备案说明四种组合： 国外域名+国外服务器，不需要备案； 国外域名+国内服务器，无法直接解析； 国内域名+国内服务器，需要； 国内域名+国外服务器，好像不太这么用； （完）","categories":[{"name":"工具教程","slug":"工具教程","permalink":"https://yuliascott.github.io/blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yuliascott.github.io/blog/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://yuliascott.github.io/blog/tags/Nginx/"}],"keywords":[{"name":"工具教程","slug":"工具教程","permalink":"https://yuliascott.github.io/blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"}]},{"title":"技术书籍清单","slug":"技术书籍清单","date":"2021-01-04T10:13:48.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"技术读物/技术书籍清单/","link":"","permalink":"https://yuliascott.github.io/blog/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%B8%85%E5%8D%95/","excerpt":"","text":"Web前端：——————————《JavaScript设计模式与开发实践》 服务器：——————————《Nginx高性能Web服务器详解》","categories":[{"name":"技术读物","slug":"技术读物","permalink":"https://yuliascott.github.io/blog/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/"}],"tags":[{"name":"书籍推荐","slug":"书籍推荐","permalink":"https://yuliascott.github.io/blog/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"}],"keywords":[{"name":"技术读物","slug":"技术读物","permalink":"https://yuliascott.github.io/blog/categories/%E6%8A%80%E6%9C%AF%E8%AF%BB%E7%89%A9/"}]},{"title":"NET开发笔记","slug":"NET笔记","date":"2020-12-31T10:13:48.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"编程语言/NET笔记/","link":"","permalink":"https://yuliascott.github.io/blog/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/NET%E7%AC%94%E8%AE%B0/","excerpt":"","text":"本文主要是Asp.NET开发备忘录，主要记录开发过程中的问题和思考。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://yuliascott.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"NET","slug":"NET","permalink":"https://yuliascott.github.io/blog/tags/NET/"}],"keywords":[{"name":"编程语言","slug":"编程语言","permalink":"https://yuliascott.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]},{"title":"搭建个人博客网站","slug":"搭建个人博客网站","date":"2020-12-28T15:58:14.000Z","updated":"2021-03-13T03:19:22.943Z","comments":true,"path":"工具教程/搭建个人博客网站/","link":"","permalink":"https://yuliascott.github.io/blog/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/","excerpt":"","text":"使用Hexo搭建博客网站，Travis CI自动集成。使用Github pages搭建Hexo静态博客网站，Hexo将编写的md文档解析渲染成Html网页，通过git推送到github，Travis CI自动检测提交的内容，根据.travis.yml自动生成、部署静态网页。参考链接：https://www.bilibili.com/read/cv2884489（文字） https://www.bilibili.com/video/av55852851/?p=1（视频） ### 搭建思路首先hexo博客的源码放在master分支上，生成的静态页面放在gh-pages分支上。当然也可以新建两个仓库，一个仓库放hexo源码，一个仓库放生成的静态页面。 ### 写在前面所需环境&amp;工具： node git Typora（编写md文章） 注：本文不涉及安装node环境和git工具；本文不涉及如何更换snippet主题； 一、创建token在github上创建token： 创建完成后，一定要复制生成的token！！！ ———————————————————————————————————————————————————————————————————————————————— 二、创建hexo官网链接：https://hexo.io/zh-cn/ 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server ———————————————————————————————————————————————————————————————————————————————— 三、创建repository在github上创建仓库(仓库名称blog，不需要以github.io结尾)，提交代码： 12345git initgit add .git commit -m &quot;first commit&quot;git remote add origin https://github.com/xxxxx/xxxxxx.gitgit push -u origin master ———————————————————————————————————————————————————————————————————————————————— 四、创建branch新建gh-pages分支(注意：gh-pages分支名，不可随意更改)： 123456789101112git checkout -b gh-pages除了.git文件夹删除所有文件git add .git commit -m &#x27;gh-pages first commit&#x27;//至此，源码分支和gh-pages分支已经全部弄好了。切回master分支：git checkout master切回master分支后，提交代码：1）git push origin master 2）git push origin gh-pages ———————————————————————————————————————————————————————————————————————————————— 五、配置travis CI打开Travis CI官网，用github来登陆，勾上对应的仓库： 点击“settings”，添加Environment Variables，在下方的Name里填入你自定义的名字（如hexoblog_token），右边的value填入github上申请的token，然后点击add ———————————————————————————————————————————————————————————————————————————————— 六、配置travis.yml在项目根目录下新建文件.travis.yml，内容如下： 1234567891011121314151617181920212223242526language: node_jsnode_js: stable #要安装的node版本为当前的稳定版cache: directories: - node_modules #要缓存的文件夹install: # - npm install hexo-cli -g - npm installscript: - hexo clean #清除 - hexo g #生成after_script: #最后执行的命令 - cd ./public - git init - git config user.name &quot;your_name&quot; - git config user.email &quot;your_email@example.com&quot; - git add . - git commit -m &quot;automatic code deployment&quot; - git push --force --quiet &quot;https://$&#123;hexoblog_token&#125;@$&#123;GH_REF&#125;&quot; master:gh-pages #hexoblog_token与travis ci设置的环境变量名相同branches: only: - master #触发持续集成的分支env: global: - GH_REF: github.com/xxxxxx/xxx.git #就是github上存放博客最终文件的仓库地址末尾加上.git 添加完成，切换到master分支，提交代码———————————————————————————————————————————————————————————————————————————————— 七、新建md文章执行hexo命令： 1hexo n &#x27;article&#x27; 执行完上面的命令，在文件夹source里面的_posts文件夹里面找到刚刚新建的article.md，编辑内容，提交代码： 123456---title: &#x27;xxxx&#x27;date: xxxxtags: &#x27;xxxx&#x27; #[&#x27;xxxx1&#x27;,&#x27;xxxx2&#x27;,&#x27;xxxx3&#x27;...]categories: &#x27;xxxxxx&#x27;--- 打开travis ci 官网，在监控的仓库中找到Build History查看提交的状态。———————————————————————————————————————————————————————————————————————————————— 八、图床神器PicGoMarkdown语法的特殊性使得图片的插入到文章尤为困难，本文由此而来。 所谓图床工具，就是自动把本地图片转换成链接的一款工具，支持七牛云，腾讯云COS，又拍云，GitHub，阿里云 OSS，SM.MS，Imgur 等8种常用图床。安装包下载：https://github.com/Molunerfinn/PicGo windows 选择 exe mac 选择 dmg linux选择 AppImage 注：mac 用户，直接使用brew cask来安装PicGo，简单方便： 1brew install --cask picgo 我使用的是Github图床： ===》登录Github创建Repository(如blogpic)，设置为public； ===》创建token，填写描述，选择repo，然后点击Generate token按钮，创建完成后复制保存； ===》安装配置PicGo； ===》上传图片，Github仓库查看图片； 安装配置PicGo: 设定仓库名的时候，是按照”账户名/仓库名”的格式填写； 分支名统一填写”master”； 将github创建的Token粘贴到这里； 存储的路径如图，会在repository下创建一个”img”文件夹； 自定义域名的作用是，在上传图片成功后，PicGo会将”自定义域名+上传的图片名”生成的访问链接放到剪切板：https://raw.githubusercontent.com/用户名/RepositoryName/分支名 或者使用cdn加速：https://cdn.jsdelivr.net/gh/用户名/RepositoryName 来加速 ———————————————————————————————————————————————————————————————————————————————— 九、RSS订阅RSS(Really Simple Syndication) 简易信息聚合，是一种描述同步网站内容的格式(xml格式)，可以通过订阅RSS源在RSS阅读器上获取更新的信息。 执行yarn或npm命令： 123yarn add hexo-generator-feed --save 或npm install hexo-generator-feed --save snippet/_config.yml文件添加：rss: /atom.xml （完）","categories":[{"name":"工具教程","slug":"工具教程","permalink":"https://yuliascott.github.io/blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://yuliascott.github.io/blog/tags/Hexo/"},{"name":"Travis CI","slug":"Travis-CI","permalink":"https://yuliascott.github.io/blog/tags/Travis-CI/"},{"name":"Github","slug":"Github","permalink":"https://yuliascott.github.io/blog/tags/Github/"}],"keywords":[{"name":"工具教程","slug":"工具教程","permalink":"https://yuliascott.github.io/blog/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"}]}]}